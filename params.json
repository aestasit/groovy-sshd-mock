{"name":"Groovy-sshd-mock","tagline":"A Groovy-based library for mocking SSH server behaviour inside a unit test.","body":"# groovy-sshd-mock\r\n\r\n## Overview\r\n\r\nThe `groovy-sshd-mock` is a simple Groovy-based library to start a mock SSH server within your unit tests. It allows defining command \r\nand file expectations.\r\n\r\n## Usage\r\n\r\nFirst of all you need to statically import `MockSshServer` class to get access to the library functionality: \r\n\r\n    import static com.aestasit.ssh.mocks.MockSshServer.*\r\n\r\nThen you can use `command`, `file` and `dir` methods to define SSH server expectations:\r\n\r\n    // Create command expectations.\r\n    command('^ls.*$') { inp, out, err, callback, env ->\r\n      out << '''total 20\r\n    drwxr-xr-x 3 1100 1100 4096 Aug  7 16:52 .\r\n    drwxr-xr-x 8 1100 1100 4096 Aug  1 17:53 ..\r\n    drwxr-xr-x 3 1100 1100 4096 Aug  7 16:49 examples\r\n    '''\r\n      callback.onExit(0)\r\n    }\r\n\r\n    // Create file expectations.\r\n    dir('/tmp/puppet')\r\n\r\nAs you can notice, the closure passed to the `command` method takes 5 parameters that allow influencing the \r\nbehavior of the mocked remote command. \r\n\r\nThe `inp`, `out`, `err` parameters are command's standard input, standard output and standard error streams. \r\nThe `callback` parameter allows setting exit code for the mocked command to return. The `env` parameter gives you \r\naccess to command's environment variables, which will most likely will be useless in a mocked environment.  \r\n\r\nAfter that is done you can start the mock server on a specific port (e.g. `2323`) and execute your SSH code against that:\r\n\r\n    // Start server.\r\n    startSshd(2323)\r\n\r\n    // Execute SSH test code (connect, execute remote commands, transfer filers, disconnect).\r\n    ...\r\n\r\nTo keep things clean you can also eventually stop the server:\r\n\r\n    // Stop server.\r\n    stopSshd()\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}